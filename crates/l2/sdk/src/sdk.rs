use std::ops::Add;
use std::{fs::read_to_string, path::Path};

use bytes::Bytes;
use calldata::encode_calldata;
use ethereum_types::{Address, H160, H256, U256};
use ethrex_common::types::TxType;
use ethrex_l2_common::calldata::Value;
use ethrex_l2_rpc::clients::send_generic_transaction;
use ethrex_l2_rpc::{
    clients::send_tx_bump_gas_exponential_backoff,
    signer::{LocalSigner, Signer},
};
use ethrex_rpc::clients::eth::L1MessageProof;
use ethrex_rpc::clients::eth::{EthClient, Overrides, errors::EthClientError};
use ethrex_rpc::types::receipt::RpcReceipt;

use keccak_hash::keccak;
use secp256k1::SecretKey;
use serde::{Deserialize, Deserializer, Serialize, Serializer};

pub mod calldata;
pub mod l1_to_l2_tx_data;

pub use l1_to_l2_tx_data::{L1ToL2TransactionData, send_l1_to_l2_tx};

// Reexport the contracts module
#[doc(inline)]
pub use ethrex_sdk_contract_utils::*;

// 0x8ccf74999c496e4d27a2b02941673f41dd0dab2a
pub const DEFAULT_BRIDGE_ADDRESS: Address = H160([
    0x8c, 0xcf, 0x74, 0x99, 0x9c, 0x49, 0x6e, 0x4d, 0x27, 0xa2, 0xb0, 0x29, 0x41, 0x67, 0x3f, 0x41,
    0xdd, 0x0d, 0xab, 0x2a,
]);

// 0x000000000000000000000000000000000000ffff
pub const COMMON_BRIDGE_L2_ADDRESS: Address = H160([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xff,
]);

// 0x000000000000000000000000000000000000fffe
pub const L2_TO_L1_MESSENGER_ADDRESS: Address = H160([
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0xfe,
]);

// 0xee110000000000000000000000000000000011ff
pub const ADDRESS_ALIASING: Address = H160([
    0xee, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x11, 0xff,
]);

pub const L2_WITHDRAW_SIGNATURE: &str = "withdraw(address)";

/// Bytecode of the OpenZeppelin's ERC1967Proxy contract.
/// This is generated by the [build script](../build.rs) only if the `COMPILE_CONTRACTS` env var is enabled.
const ERC1967_PROXY_BYTECODE: &[u8] = include_bytes!(concat!(
    env!("OUT_DIR"),
    "/contracts/solc_out/ERC1967Proxy.bytecode"
));

#[derive(Debug, thiserror::Error)]
pub enum SdkError {
    #[error("Failed to parse address from hex")]
    FailedToParseAddressFromHex,
}

/// BRIDGE_ADDRESS or 0x554a14cd047c485b3ac3edbd9fbb373d6f84ad3f
pub fn bridge_address() -> Result<Address, SdkError> {
    std::env::var("ETHREX_WATCHER_BRIDGE_ADDRESS")
        .unwrap_or(format!("{DEFAULT_BRIDGE_ADDRESS:#x}"))
        .parse()
        .map_err(|_| SdkError::FailedToParseAddressFromHex)
}

pub async fn wait_for_transaction_receipt(
    tx_hash: H256,
    client: &EthClient,
    max_retries: u64,
) -> Result<RpcReceipt, EthClientError> {
    let mut receipt = client.get_transaction_receipt(tx_hash).await?;
    let mut r#try = 1;
    while receipt.is_none() {
        println!("[{try}/{max_retries}] Retrying to get transaction receipt for {tx_hash:#x}");

        if max_retries == r#try {
            return Err(EthClientError::Custom(format!(
                "Transaction receipt for {tx_hash:#x} not found after {max_retries} retries"
            )));
        }
        r#try += 1;

        tokio::time::sleep(std::time::Duration::from_secs(2)).await;

        receipt = client.get_transaction_receipt(tx_hash).await?;
    }
    receipt.ok_or(EthClientError::Custom(
        "Transaction receipt is None".to_owned(),
    ))
}

pub async fn transfer(
    amount: U256,
    from: Address,
    to: Address,
    private_key: &SecretKey,
    client: &EthClient,
) -> Result<H256, EthClientError> {
    println!("Transferring {amount} from {from:#x} to {to:#x}");
    let gas_price = client
        .get_gas_price_with_extra(20)
        .await?
        .try_into()
        .map_err(|_| {
            EthClientError::InternalError("Failed to convert gas_price to a u64".to_owned())
        })?;

    let tx = client
        .build_generic_tx(
            TxType::EIP1559,
            to,
            from,
            Default::default(),
            Overrides {
                value: Some(amount),
                max_fee_per_gas: Some(gas_price),
                max_priority_fee_per_gas: Some(gas_price),
                ..Default::default()
            },
        )
        .await?;

    let signer = LocalSigner::new(*private_key).into();
    send_generic_transaction(client, tx, &signer).await
}

pub async fn deposit_through_transfer(
    amount: U256,
    from: Address,
    from_pk: &SecretKey,
    eth_client: &EthClient,
) -> Result<H256, EthClientError> {
    println!("Depositing {amount} from {from:#x} to bridge");
    transfer(
        amount,
        from,
        bridge_address().map_err(|err| EthClientError::Custom(err.to_string()))?,
        from_pk,
        eth_client,
    )
    .await
}

pub async fn withdraw(
    amount: U256,
    from: Address,
    from_pk: SecretKey,
    proposer_client: &EthClient,
) -> Result<H256, EthClientError> {
    let withdraw_transaction = proposer_client
        .build_generic_tx(
            TxType::EIP1559,
            COMMON_BRIDGE_L2_ADDRESS,
            from,
            Bytes::from(encode_calldata(
                L2_WITHDRAW_SIGNATURE,
                &[Value::Address(from)],
            )?),
            Overrides {
                value: Some(amount),
                ..Default::default()
            },
        )
        .await?;

    let signer = LocalSigner::new(from_pk).into();

    send_generic_transaction(proposer_client, withdraw_transaction, &signer).await
}

pub async fn claim_withdraw(
    amount: U256,
    from: Address,
    from_pk: SecretKey,
    eth_client: &EthClient,
    message_proof: &L1MessageProof,
) -> Result<H256, EthClientError> {
    println!("Claiming {amount} from bridge to {from:#x}");

    const CLAIM_WITHDRAWAL_SIGNATURE: &str = "claimWithdrawal(uint256,uint256,uint256,bytes32[])";

    let calldata_values = vec![
        Value::Uint(amount),
        Value::Uint(message_proof.batch_number.into()),
        Value::Uint(message_proof.message_id),
        Value::Array(
            message_proof
                .merkle_proof
                .iter()
                .map(|hash| Value::FixedBytes(hash.as_fixed_bytes().to_vec().into()))
                .collect(),
        ),
    ];

    let claim_withdrawal_data = encode_calldata(CLAIM_WITHDRAWAL_SIGNATURE, &calldata_values)?;

    println!(
        "Claiming withdrawal with calldata: {}",
        hex::encode(&claim_withdrawal_data)
    );

    let claim_tx = eth_client
        .build_generic_tx(
            TxType::EIP1559,
            bridge_address().map_err(|err| EthClientError::Custom(err.to_string()))?,
            from,
            claim_withdrawal_data.into(),
            Overrides {
                from: Some(from),
                ..Default::default()
            },
        )
        .await?;

    let signer = LocalSigner::new(from_pk).into();

    send_generic_transaction(eth_client, claim_tx, &signer).await
}

pub async fn claim_erc20withdraw(
    token_l1: Address,
    token_l2: Address,
    amount: U256,
    from_signer: &Signer,
    eth_client: &EthClient,
    message_proof: &L1MessageProof,
) -> Result<H256, EthClientError> {
    let from = from_signer.address();
    const CLAIM_WITHDRAWAL_ERC20_SIGNATURE: &str =
        "claimWithdrawalERC20(address,address,uint256,uint256,uint256,bytes32[])";

    let calldata_values = vec![
        Value::Address(token_l1),
        Value::Address(token_l2),
        Value::Uint(amount),
        Value::Uint(U256::from(message_proof.batch_number)),
        Value::Uint(message_proof.message_id),
        Value::Array(
            message_proof
                .merkle_proof
                .iter()
                .map(|v| Value::Uint(U256::from_big_endian(v.as_bytes())))
                .collect(),
        ),
    ];

    let claim_withdrawal_data =
        encode_calldata(CLAIM_WITHDRAWAL_ERC20_SIGNATURE, &calldata_values)?;

    println!(
        "Claiming withdrawal with calldata: {}",
        hex::encode(&claim_withdrawal_data)
    );

    let claim_tx = eth_client
        .build_generic_tx(
            TxType::EIP1559,
            bridge_address().map_err(|err| EthClientError::Custom(err.to_string()))?,
            from,
            claim_withdrawal_data.into(),
            Overrides {
                from: Some(from),
                ..Default::default()
            },
        )
        .await?;

    send_generic_transaction(eth_client, claim_tx, from_signer).await
}

pub async fn deposit_erc20(
    token_l1: Address,
    token_l2: Address,
    amount: U256,
    from: Address,
    from_signer: &Signer,
    eth_client: &EthClient,
) -> Result<H256, EthClientError> {
    println!("Claiming {amount} from bridge to {from:#x}");

    const DEPOSIT_ERC20_SIGNATURE: &str = "depositERC20(address,address,address,uint256)";

    let calldata_values = vec![
        Value::Address(token_l1),
        Value::Address(token_l2),
        Value::Address(from),
        Value::Uint(amount),
    ];

    let deposit_data = encode_calldata(DEPOSIT_ERC20_SIGNATURE, &calldata_values)?;

    let mut deposit_tx = eth_client
        .build_generic_tx(
            TxType::EIP1559,
            bridge_address().map_err(|err| EthClientError::Custom(err.to_string()))?,
            from,
            deposit_data.into(),
            Overrides {
                from: Some(from),
                ..Default::default()
            },
        )
        .await?;

    deposit_tx.gas = deposit_tx.gas.map(|gas| gas * 2); // tx reverts in some cases otherwise

    send_generic_transaction(eth_client, deposit_tx, from_signer).await
}

pub fn secret_key_deserializer<'de, D>(deserializer: D) -> Result<SecretKey, D::Error>
where
    D: Deserializer<'de>,
{
    let hex = H256::deserialize(deserializer)?;
    SecretKey::from_slice(hex.as_bytes()).map_err(serde::de::Error::custom)
}

pub fn secret_key_serializer<S>(secret_key: &SecretKey, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let hex = H256::from_slice(&secret_key.secret_bytes());
    hex.serialize(serializer)
}

pub fn get_address_from_secret_key(secret_key: &SecretKey) -> Result<Address, EthClientError> {
    let public_key = secret_key
        .public_key(secp256k1::SECP256K1)
        .serialize_uncompressed();
    let hash = keccak(&public_key[1..]);

    // Get the last 20 bytes of the hash
    let address_bytes: [u8; 20] = hash
        .as_ref()
        .get(12..32)
        .ok_or(EthClientError::Custom(
            "Failed to get_address_from_secret_key: error slicing address_bytes".to_owned(),
        ))?
        .try_into()
        .map_err(|err| {
            EthClientError::Custom(format!("Failed to get_address_from_secret_key: {err}"))
        })?;

    Ok(Address::from(address_bytes))
}

// 0x4e59b44847b379578588920cA78FbF26c0B4956C
const DETERMINISTIC_CREATE2_ADDRESS: Address = H160([
    0x4e, 0x59, 0xb4, 0x48, 0x47, 0xb3, 0x79, 0x57, 0x85, 0x88, 0x92, 0x0c, 0xa7, 0x8f, 0xbf, 0x26,
    0xc0, 0xb4, 0x95, 0x6c,
]);

#[derive(Default)]
pub struct ProxyDeployment {
    pub proxy_address: Address,
    pub proxy_tx_hash: H256,
    pub implementation_address: Address,
    pub implementation_tx_hash: H256,
}

#[derive(Debug, thiserror::Error)]
pub enum DeployError {
    #[error("Failed to decode init code: {0}")]
    FailedToReadInitCode(#[from] std::io::Error),
    #[error("Failed to decode init code: {0}")]
    FailedToDecodeBytecode(#[from] hex::FromHexError),
    #[error("Failed to deploy contract: {0}")]
    FailedToDeploy(#[from] EthClientError),
    #[error("Proxy bytecode not found. Make sure to compile the sdk with `COMPILE_CONTRACTS` set.")]
    ProxyBytecodeNotFound,
}

pub async fn deploy_contract(
    constructor_args: &[u8],
    contract_path: &Path,
    deployer: &Signer,
    salt: &[u8],
    eth_client: &EthClient,
) -> Result<(H256, Address), DeployError> {
    let bytecode = hex::decode(read_to_string(contract_path)?)?;
    deploy_contract_from_bytecode(constructor_args, &bytecode, deployer, salt, eth_client).await
}

/// Same as `deploy_contract`, but takes the bytecode directly instead of a path.
pub async fn deploy_contract_from_bytecode(
    constructor_args: &[u8],
    bytecode: &[u8],
    deployer: &Signer,
    salt: &[u8],
    eth_client: &EthClient,
) -> Result<(H256, Address), DeployError> {
    let init_code = [bytecode, constructor_args].concat();
    let (deploy_tx_hash, contract_address) =
        create2_deploy(salt, &init_code, deployer, eth_client).await?;
    Ok((deploy_tx_hash, contract_address))
}

/// Deploys a contract behind an OpenZeppelin's `ERC1967Proxy`.
/// The embedded `ERC1967_PROXY_BYTECODE` may be empty if the crate was compiled
/// without the `COMPILE_CONTRACTS` env var set. In that case, this function
/// will return `DeployError::ProxyBytecodeNotFound`.
async fn deploy_proxy(
    deployer: &Signer,
    eth_client: &EthClient,
    implementation_address: Address,
    salt: &[u8],
) -> Result<(H256, Address), DeployError> {
    #[allow(clippy::const_is_empty)]
    if ERC1967_PROXY_BYTECODE.is_empty() {
        return Err(DeployError::ProxyBytecodeNotFound);
    }

    let mut init_code = ERC1967_PROXY_BYTECODE.to_vec();

    init_code.extend(H256::from(implementation_address).0);
    init_code.extend(H256::from_low_u64_be(0x40).0);
    init_code.extend(H256::zero().0);

    let (deploy_tx_hash, proxy_address) =
        create2_deploy(salt, &Bytes::from(init_code), deployer, eth_client)
            .await
            .map_err(DeployError::from)?;

    Ok((deploy_tx_hash, proxy_address))
}

/// Deploys a contract behind an OpenZeppelin's `ERC1967Proxy`.
pub async fn deploy_with_proxy(
    deployer: &Signer,
    eth_client: &EthClient,
    contract_path: &Path,
    salt: &[u8],
) -> Result<ProxyDeployment, DeployError> {
    let (implementation_tx_hash, implementation_address) =
        deploy_contract(&[], contract_path, deployer, salt, eth_client).await?;

    let (proxy_tx_hash, proxy_address) =
        deploy_proxy(deployer, eth_client, implementation_address, salt).await?;

    Ok(ProxyDeployment {
        proxy_address,
        proxy_tx_hash,
        implementation_address,
        implementation_tx_hash,
    })
}

/// Same as `deploy_with_proxy`, but takes the contract bytecode directly instead of a path.
pub async fn deploy_with_proxy_from_bytecode(
    deployer: &Signer,
    eth_client: &EthClient,
    bytecode: &[u8],
    salt: &[u8],
) -> Result<ProxyDeployment, DeployError> {
    let (implementation_tx_hash, implementation_address) =
        deploy_contract_from_bytecode(&[], bytecode, deployer, salt, eth_client).await?;

    let (proxy_tx_hash, proxy_address) =
        deploy_proxy(deployer, eth_client, implementation_address, salt).await?;

    Ok(ProxyDeployment {
        proxy_address,
        proxy_tx_hash,
        implementation_address,
        implementation_tx_hash,
    })
}

async fn create2_deploy(
    salt: &[u8],
    init_code: &[u8],
    deployer: &Signer,
    eth_client: &EthClient,
) -> Result<(H256, Address), EthClientError> {
    let calldata = [salt, init_code].concat();
    let gas_price = eth_client
        .get_gas_price_with_extra(20)
        .await?
        .try_into()
        .map_err(|_| {
            EthClientError::InternalError("Failed to convert gas_price to a u64".to_owned())
        })?;

    let deploy_tx = eth_client
        .build_generic_tx(
            TxType::EIP1559,
            DETERMINISTIC_CREATE2_ADDRESS,
            deployer.address(),
            calldata.into(),
            Overrides {
                max_fee_per_gas: Some(gas_price),
                max_priority_fee_per_gas: Some(gas_price),
                ..Default::default()
            },
        )
        .await?;

    let deploy_tx_hash =
        send_tx_bump_gas_exponential_backoff(eth_client, deploy_tx, deployer).await?;

    wait_for_transaction_receipt(deploy_tx_hash, eth_client, 10).await?;

    let deployed_address = create2_address(salt, keccak(init_code));

    Ok((deploy_tx_hash, deployed_address))
}

#[allow(clippy::indexing_slicing)]
fn create2_address(salt: &[u8], init_code_hash: H256) -> Address {
    Address::from_slice(
        &keccak(
            [
                &[0xff],
                DETERMINISTIC_CREATE2_ADDRESS.as_bytes(),
                salt,
                init_code_hash.as_bytes(),
            ]
            .concat(),
        )
        .as_bytes()[12..],
    )
}

pub async fn initialize_contract(
    contract_address: Address,
    initialize_calldata: Vec<u8>,
    initializer: &Signer,
    eth_client: &EthClient,
) -> Result<H256, EthClientError> {
    let gas_price = eth_client
        .get_gas_price_with_extra(20)
        .await?
        .try_into()
        .map_err(|_| {
            EthClientError::InternalError("Failed to convert gas_price to a u64".to_owned())
        })?;

    let initialize_tx = eth_client
        .build_generic_tx(
            TxType::EIP1559,
            contract_address,
            initializer.address(),
            initialize_calldata.into(),
            Overrides {
                max_fee_per_gas: Some(gas_price),
                max_priority_fee_per_gas: Some(gas_price),
                ..Default::default()
            },
        )
        .await?;

    let initialize_tx_hash =
        send_tx_bump_gas_exponential_backoff(eth_client, initialize_tx, initializer).await?;

    Ok(initialize_tx_hash)
}

pub async fn call_contract(
    client: &EthClient,
    private_key: &SecretKey,
    to: Address,
    signature: &str,
    parameters: Vec<Value>,
) -> Result<H256, EthClientError> {
    let calldata = encode_calldata(signature, &parameters)?.into();
    let signer: Signer = Signer::Local(LocalSigner::new(*private_key));
    let from = signer.address();
    let tx = client
        .build_generic_tx(TxType::EIP1559, to, from, calldata, Default::default())
        .await?;

    let tx_hash = send_generic_transaction(client, tx, &signer).await?;

    wait_for_transaction_receipt(tx_hash, client, 100).await?;
    Ok(tx_hash)
}

pub fn address_to_word(address: Address) -> U256 {
    let mut word = [0u8; 32];
    for (word_byte, address_byte) in word.iter_mut().skip(12).zip(address.as_bytes().iter()) {
        *word_byte = *address_byte;
    }
    U256::from_big_endian(&word)
}

pub fn get_erc1967_slot(name: &str) -> U256 {
    U256::from_big_endian(&keccak(name).0) - U256::one()
}

pub fn get_address_alias(address: Address) -> Address {
    let address = U256::from_big_endian(&address.to_fixed_bytes());
    let alias = address.add(U256::from_big_endian(&ADDRESS_ALIASING.to_fixed_bytes()));
    H160::from_slice(&alias.to_big_endian()[12..32])
}

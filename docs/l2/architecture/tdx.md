# TDX execution module

This document has documentation related to proving ethrex blocks using TDX.

## Usage

> [!NOTE]
>
> - Running the following without an L2 running will continuously throw the error: `Error sending quote: Failed to get ProverSetupAck: Connection refused (os error 111)`. If you want to run this in a proper setup go to the [Running](#running) section.
> - The quote generator runs in a QEMU, to quit it press `CTRL+A X`.

On a machine with TDX support [with the required setup](https://github.com/canonical/tdx) go to quote-gen and run

```sh
make run
```

## What is TDX?

TDX is an Intel technology implementing a Trusted Execution Environment.
Such an environment allows verifying certain code was executed without being tampered with or observed.

These verifications (attestations) are known as "quotes" and contain signatures verifying the attestation was generated by a genuine processor, the measurements at the time, and a user-provided piece of data binding the proof.

The measurements are saved to four Run Time Measurement Registers (RTMR), with each RTMR respresenting a boot stage.
This is analogous to [how PCRs work](https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/).

## Usage considerations

Do not hardcode quote verification parameters as [they might change](https://cc-enabling.trustedservices.intel.com/intel-tdx-enabling-guide/02/infrastructure_setup/#tcb-recovery-tcb-r).

It's easy to silently overlook non-verified areas such as accidentally leaving login enabled, or not verifying the integrity of the state.

## Boot sequence

- Firmware (OVMF here) is loaded (and hashed into RTMR\[0\])
- [UKI](https://uapi-group.org/specifications/specs/unified_kernel_image/) is loaded (and hashed into a RTMR)
- kernel and initrd are extracted from the UKI and executed
- root partition is verified using the `roothash=` value provided on the kernel cmdline and the `hash` partition with the dm-verity merkle tree
- root partition is mounted read-only
- (WIP) systemd executes the payload

## Image build components

For reproducibility of images and hypervisor runtime we use [Nix](https://en.wikipedia.org/wiki/Nix_(package_manager)).

### hypervisor.nix

This builds the modified (with patches for TDX support) qemu, and TDX-specific VBIOS (OVMF) and exports a script to run a given image (the parameters, specifically added devices, affect the measurements).

### service.nix

This contains the quote-gen service. It's hash changes every time a non-gitignored file changes.

### image.nix

Exports an image that uses [UKI](https://uapi-group.org/specifications/specs/unified_kernel_image/) and [dm-verity](https://source.android.com/docs/security/features/verifiedboot/dm-verity?hl=en) to generate an image where changing any component changes the hash of the bootloader (the UKI image), which is measured by the BIOS.

## Running

You can enable the prover by setting `ETHREX_L2_TDX=true`.

For development purposes, you can use the flag `ETHREX_TDX_DEV_MODE=true` to disable quote verification. This allows you to run the quote generator even without having TDX-capable hardware.

Ensure the proof coordinator is reachable at 172.17.0.1. You can bring up the network by first starting the L2 components:

```sh
// cd crates/l2
make init ETHREX_L2_TDX=true PROOF_COORDINATOR_ADDRESS=0.0.0.0
```

And in another terminal, running the VM:

```sh
// cd crates/l2
make -C tee/quote-gen run
```

## Troubleshooting

### `unshare: write failed /proc/self/uid_map: Operation not permitted`

If you get this error when building the image, it's probably because your OS has unprivileged userns restricted by default. You can undo this by running the following commands as root, or running the build as root while disabling sandboxing.

```sh
sysctl kernel.unprivileged_userns_apparmor_policy=0
sysctl kernel.apparmor_restrict_unprivileged_userns=0
```

### RTMR/MRTD mismatch

If any code or dependencies changed, the measurements will change.

To obtain the new measurements, first you obtain the quote by running the prover (you don't need to have the l2 running). It's output will contain `Sending quote <very long hex string>`.

This usually causes a RTMR1 mismatch. The easiest way to obtain the new RTMR values is by looking at the printed quote for the next 96 bytes after the RTMR0, corresponding to RTMR1||RTMR2 (48 bytes each).

More generally, you can generate a report with DCAP.verifyAndAttestOnChain(quote) which validates and extracts the report.

Look at bytes 341..485 of the output for RTMRs and bytes 149..197 for the MRTD.

For example, the file `quote.example` contains a quote, which can be turned into the following report:

```text
00048100000000b0c06f000000060103000000000000000000000000005b38e33a6487958b72c3c12a938eaa5e3fd4510c51aeeab58c7d5ecee41d7c436489d6c8e4f92f160b7cad34207b00c100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000e702060000000000

91eb2b44d141d4ece09f0c75c2c53d247a3c68edd7fafe8a3520c942a604a407de03ae6dc5f87f27428b2538873118b7 # MRTD

000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

4f3d617a1c89bd9a89ea146c15b04383b7db7318f41a851802bba8eace5a6cf71050e65f65fd50176e4f006764a42643 # RTMR0
53827a034d1e4c7f13fd2a12aee4497e7097f15a04794553e12fe73e2ffb8bd57585e771951115a13ec4d7e6bc193038 # RTMR1
2ca1a728ff13c36195ad95e8f725bf00d7f9c5d6ed730fb8f50cccad692ab81aefc83d594819375649be934022573528 # RTMR2
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 # RTMR3

39618efd10b14136ab416d6acfff8e36b23533a90000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```
